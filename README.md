# Spring boot Security oAuth (using Github)

Basic Spring boot Security OAuth (using Github). Angular code is not covered here, but the calls are mocked using Thunderclient requests.

## Overview of Components

- Spring boot Backend Service (uses Github OAuth)
  - TokenStore: Generate token from/to authentication.
  - SecurityConfig.successHandler: Generate the token using the TokenStore call and return the token in the response to clients on auth success.
  - SecurityConfig.authenticationEntryPoint: Unauthenticated request will be shown 401 unauthorized error.
  - SecurityConfig.corsConfiguration: Allow XHR requests.
  - InMemoryRequestRepository: Use HashMap to hold the OAuthRequest in-memmory temporarily while the request is begin processed by Github.
  - HomeController.username: Get the username.
- Angular Client (Mocked via Thunderclient)
  - Login Component: Show the login button.
  - Callback Component: Github redirects to this callback URL.
  - Home Component: Access post login.
  - AuthGaurd: Check if the user is authenticated or not. Unauthenticated users redirected to login.
  - Header Interceptor: Put Auth HTTP header in each request.

## Setup Github

- Go to Github > Settings > Developer settings > OAuth Apps
- Click on 'Register a new application'. 
  - Set homepage URL to http://localhost:4200
  - Set callback URL to http://localhost:4200/callback
- You will be provided Client ID and Client secrets.

## Application Properties

- Refer `application.properties` for `client-id`, `client-secret` and `redirectUri`. 
- The `client-id` and `client-secret` is generated when you onboard your application on Github (steps given above).
- `redirectUri` is the callback url of your Angular application where `code-id` and `state` will be sent by Github oAuth.

## SecurityConfig Class

- `config.SecurityConfig` class extends `WebSecurityConfigurerAdapter` and uses `@EnableWebSecurity`.
- Configuration allows access to oAuth and login URLs without the need of authentication. Any other request to the URIs should be authenticated.
- Upon success, the auth object will be converted to JWT token via `TokenStore`class. Unauthenticated request will be shown 401 unauthorized error.
- The authorization requests are stored in-memory using HashMap for now by `config.InMemoryRequestRepository` class.

## Token Store Class

- We can define our own custom method to generate the JWTs. This is covered under `config.TokenStore` class.
- `config.SecurityConfig.successHandler()` (When oAuth is successful) calls `config.TokenStore` to create custom token store (generates JWT and store it in Hashmap cache).

## Token Filter Class

- The `TokenFilter` class extends `OncePerRequestFilter`. 
- It checks the authorization token in the header. 
- If the authorization token is found, it spilts the 'Bearer' part away.
- After this we check if the token is present in the Token Store. 
- If yes, we place it inside the security context.

## InMemoryRequestRepository Class

- Holds the OAuth request temporarily in-memory while the Github request is being made.
- If the request contains 'state' parameter, the logic removes previous cached value from the in-memory cache and returns the removed cache value.
- On the other hand `saveAuthorizationRequest` saves the authorizationRequest in the cache.

# Overview of Token generation and Github Principals

```
OAuth2AuthenticationToken returned by Github after successful authorization includes many principals 
and user parameters but not the token. Token is generated by this Springboot service as we 
know that the oAuth is successful, we can create and provide our own token now to the UI.
NOTE: Refer HomeController to check the values returned by Github in OAuth2AuthenticationToken.
NOTE: In oAuth framework, Resource Server provides resources (user info, photos, etc) and Authorization 
Server manages tokens.
NOTE: Github is the Resource Server for user info. This Spring boot service is the Authorization 
Server which manages token inside HashMap cache.
```

- `TokenStore` class generates a JWT token using UUID and stores the Github principals corresponding to the generated JWT in a HashMap.

![HashMap Cache Sample](/src/main/resources/images/hashmap-jwt-cache.png "HashMap Cache Sample")

- `TokenFilter` extends `OncePerRequestFilter` and checks for JWT in HashMap cache in each request. 

## oAuth Flow

- The user visits the UI hosted on http://localhost:4200/home. [This project does not have the UI component]
- The UI > AuthGaurd checks if the user is authenticated. If yes he is redirected to http://localhost:4200/home.
- If the user is not authenticated, AuthGaurd redirects the user to our Spring boot service URL http://localhost:8080/oauth2/authorization/github.
- http://localhost:8080/oauth2/authorization/github build the URL and further redirects the user to https://github.com/login/oauth/authorize.
- The user grants access to the user on Github.
- Github then redirects to the UI callback URL with the `state` and `code` parameters http://localhost:4200/callback?code=693c1a4f4feba855856d&state=OeAR4rYKywzIry-4HsSQCjsPXNPdOuXoAXz_dsbD9GA%3D
- UI further redirect the `state` and `code` parameters to our Spring boot service URL http://localhost:8080/login/oauth2/code/github?code=693c1a4f4feba855856d&state=OeAR4rYKywzIry-4HsSQCjsPXNPdOuXoAXz_dsbD9GA%3D
- Our Springboot service get back the `accessToken` and builds its own JWT token using it. This custom token is then returned to the UI.
  
```
{accessToken: "353f02d2-e804-49bf-8257-73af6bc1597e"}
```

- UI stores the custom JWT token inside local storage. 
- UI Header Interceptor then places Authorization Bearer token in each server request to fetch user detials (fetched from Resource Server Github).

## Mock oAuth without UI

## Scalability

- The HashMap cache contains key-value pairs of JWT token and Github User Principals. 
- As requests grow, key-value pairs for each token can be fetched easily.
- We can have many users, each of them will have their own Github User Principals inside this Spring boot service (Authorization server) and access token will be maintained by the UI inside the local storage.
